#version 460
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image3D generated_data;

#define IV -2

struct Vertex {
	vec4 pos;
	vec4 normal;
	vec4 material; // material_index, tex_coords
	// The doccumentation warns against using vec3s
};

uint sizeofVec4 = 4 * 4;
uint sizeofVertex = 3 * sizeofVec4;

layout (binding=0, std140) buffer vertex_output {
	Vertex verticies[];
};

uniform vec3 pos = vec3(0.0);
uniform float maxFill = 1.0;
uniform float minFill = 0.0;

const float isolevel = 0.0;
vec3 vec3interpolate(vec3 v1, float f1, vec3 v2, float f2) {
	// Code adapted from paulbourke.net/geometry/polygonise/
	if (abs(isolevel - f1) < 0.00001 || abs(f1 - f2) < 0.00001)
		return v1;
	if (abs(isolevel - f2) < 0.00001)
		return v2;

	return v1 + vec3((isolevel - f1) / (f2 - f1)) * (v2 - v1);
}

//void add_vertex(uint starting_index, uint case_index, bool is_water_surface, int i, int vertex_index) {
//	const ivec3 cube_location = ivec3(gl_GlobalInvocationID) / sizeofVertex;
//	const vec3 offset = vec3(cube_location) + pos;
//	const uint index = starting_index + i;
//	const uint edge_index = cases[case_index][i + vertex_index];
//	const vec4 attribute_vec = (corners[edges[edge_index][0]].x > corners[edges[edge_index][1]].x) ? corners[edges[edge_index][0]] : corners[edges[edge_index][1]];
//
//	verticies[index + vertex_index].pos = vec4(vec3interpolate(vertex_pos[edges[edge_index][0]], corners[edges[edge_index][0]].x, vertex_pos[edges[edge_index][1]], corners[edges[edge_index][1]].x), 1.0);
//	verticies[index + vertex_index].pos += vec4(offset, 0.0);
//				
//	// Decide material
//	verticies[index + vertex_index].material = vec4(attribute_vec.y, attribute_vec.z, 0.0, 0.0);
//				
//	// check if material should be water
//	verticies[index + vertex_index].material.x = is_water_surface ? 0.0 : verticies[index + vertex_index].material.x;
//	// If the material is water, we want it to ripple with waves
//	// To do that we need to change the position of the verticies in the vertex shader, which changes the normals
//	// To calculate the normals, we need to know where the other two verticies in the triangle are
//	// A number (triangle_index * 3 + vertex_index) gives us enough information to solve for these locations
//	// since we know the water surface is normally a flat square made of 2 triangles
//	// We encode this number in the magnitude of the normal (which is really just the y element since the surface is flat)
//	verticies[index + vertex_index].normal = vec4(0.0);
//	verticies[index + vertex_index].normal.y = is_water_surface ? float(i + vertex_index) : 0.0;
//	verticies[index + vertex_index].normal.y = is_water_surface ? 4.0 : verticies[index + vertex_index].normal.y;
//}

void main() {
	uint index = gl_GlobalInvocationID.x;
	const float start = verticies[index].pos.x;
	if (start == 0) {return;} // We don't need or want a vertex on this edge

	const ivec3 axies[3] = {ivec3(1, 0, 0), ivec3(0, 1, 0), ivec3(0, 0, 1)};
	const uint z = index / 1024;
    const uint sindex = index - (z * 1024);

	// Get back points from the edge
	const ivec3 point_a = ivec3(sindex % 32, sindex / 32, z);
	const ivec3 point_b = point_a + axies[index % 3]; // see genIndices

	const vec3 true_point_a = vec3(point_a) + pos;
	const vec3 true_point_b = vec3(point_b) + pos;

	vec4 data_a = imageLoad(generated_data, point_a);
	vec4 data_b = imageLoad(generated_data, point_b);
	// Input format: fill, material, waterlevel, 1.0

	Vertex vertex;
	vertex.pos = vec4(vec3interpolate(true_point_a, data_a.x, true_point_b, data_b.x), 1.0);
	vertex.normal = vec4(1.0, 0.0, 0.0, 0.0);
	vertex.material = data_a.x > data_b.y ? vec4(data_a.y, data_a.z, 0.0, 0.0) : vec4(data_b.y, data_b.z, 0.0, 0.0);

	//Output vertex
	verticies[index] = vertex;
}