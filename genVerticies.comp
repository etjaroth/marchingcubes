#version 460
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image3D generated_data;

#define IV -2

struct Vertex {
	vec4 pos;
	vec4 normal;
	vec4 material; // material_index, tex_coords
	// The doccumentation warns against using vec3s
};

uint sizeofVec4 = 4 * 4;
uint sizeofVertex = 3 * sizeofVec4;

layout (binding=0, std140) buffer vertex_output {
	Vertex verticies[];
};

uniform vec3 pos = vec3(0.0);
uniform float maxFill = 1.0;
uniform float minFill = 0.0;
uniform ivec3 chunk_size;

const float isolevel = 0.0;
vec3 vec3interpolate(vec3 v1, float f1, vec3 v2, float f2) {
	//return (v1+v2)/2.0;


	// Code adapted from paulbourke.net/geometry/polygonise/
	if (abs(isolevel - f1) < 0.00001 || abs(f1 - f2) < 0.00001)
		return v1;
	if (abs(isolevel - f2) < 0.00001)
		return v2;

	return v1 + vec3((isolevel - f1) / (f2 - f1)) * (v2 - v1);
}

//void add_vertex(uint starting_index, uint case_index, bool is_water_surface, int i, int vertex_index) {
//	const ivec3 cube_location = ivec3(gl_GlobalInvocationID) / sizeofVertex;
//	const vec3 offset = vec3(cube_location) + pos;
//	const uint index = starting_index + i;
//	const uint edge_index = cases[case_index][i + vertex_index];
//	const vec4 attribute_vec = (corners[edges[edge_index][0]].x > corners[edges[edge_index][1]].x) ? corners[edges[edge_index][0]] : corners[edges[edge_index][1]];
//
//	verticies[index + vertex_index].pos = vec4(vec3interpolate(vertex_pos[edges[edge_index][0]], corners[edges[edge_index][0]].x, vertex_pos[edges[edge_index][1]], corners[edges[edge_index][1]].x), 1.0);
//	verticies[index + vertex_index].pos += vec4(offset, 0.0);
//				
//	// Decide material
//	verticies[index + vertex_index].material = vec4(attribute_vec.y, attribute_vec.z, 0.0, 0.0);
//				
//	// check if material should be water
//	verticies[index + vertex_index].material.x = is_water_surface ? 0.0 : verticies[index + vertex_index].material.x;
//	// If the material is water, we want it to ripple with waves
//	// To do that we need to change the position of the verticies in the vertex shader, which changes the normals
//	// To calculate the normals, we need to know where the other two verticies in the triangle are
//	// A number (triangle_index * 3 + vertex_index) gives us enough information to solve for these locations
//	// since we know the water surface is normally a flat square made of 2 triangles
//	// We encode this number in the magnitude of the normal (which is really just the y element since the surface is flat)
//	verticies[index + vertex_index].normal = vec4(0.0);
//	verticies[index + vertex_index].normal.y = is_water_surface ? float(i + vertex_index) : 0.0;
//	verticies[index + vertex_index].normal.y = is_water_surface ? 4.0 : verticies[index + vertex_index].normal.y;
//}

vec3 index_to_points(uint index) {
    uint d = index % 3;
    uint i = (index - d)/3;

	vec3 v;

    v.z = i / (chunk_size.x * chunk_size.y);
    i -= v.z * chunk_size.x * chunk_size.y;
    v.y = i / chunk_size.x;
    v.x = i % chunk_size.x;

    return v;
}

void main() {
	uint idx = gl_GlobalInvocationID.x;
	const ivec3 axies[3] = {ivec3(1, 0, 0), ivec3(0, 1, 0), ivec3(0, 0, 1)};
	uint axis_id = idx % 3;
	uint i = (idx - axis_id)/3;

	// Read output from genIndicies.comp
	const float start = verticies[idx].pos.x;
	const float waterlevel = verticies[idx].pos.y;

	if (start == 0) {return;} // We don't need or want a vertex on this edge
	
	
	const uint z = i / (chunk_size.x * chunk_size.y);
    i -= (z * (chunk_size.x * chunk_size.y));

	// Get back points from the edge
	ivec3 point_a = ivec3(i % chunk_size.x, i / chunk_size.x, z);
	ivec3 point_b = point_a + axies[axis_id]; // see genIndices

	const vec3 true_point_a = vec3(point_a) + pos;
	const vec3 true_point_b = vec3(point_b) + pos;

	//point_a += ivec3(1);
	//point_b += ivec3(1);

	vec4 data_a = imageLoad(generated_data, point_a);
	vec4 data_b = imageLoad(generated_data, point_b);
	// Input format: fill, material, waterlevel, 1.0

	Vertex vertex;
	vertex.pos = vec4(vec3interpolate(true_point_a, data_a.x, true_point_b, data_b.x), 1.0);

	// Calculate normal
	// Sample a[dir][positive/negative]
	float axp = imageLoad(generated_data, point_a + ivec3(1, 0, 0)).x;
	float axn = imageLoad(generated_data, point_a + ivec3(-1, 0, 0)).x;
	float ayp = imageLoad(generated_data, point_a + ivec3(0, 1, 0)).x;
	float ayn = imageLoad(generated_data, point_a + ivec3(0, -1, 0)).x;
	float azp = imageLoad(generated_data, point_a + ivec3(0, 0, 1)).x;
	float azn = imageLoad(generated_data, point_a + ivec3(0, 0, -1)).x;

	// Sample b[dir][positive/negative]
	float bxp = imageLoad(generated_data, point_b + ivec3(1, 0, 0)).x;
	float bxn = imageLoad(generated_data, point_b + ivec3(-1, 0, 0)).x;
	float byp = imageLoad(generated_data, point_b + ivec3(0, 1, 0)).x;
	float byn = imageLoad(generated_data, point_b + ivec3(0, -1, 0)).x;
	float bzp = imageLoad(generated_data, point_b + ivec3(0, 0, 1)).x;
	float bzn = imageLoad(generated_data, point_b + ivec3(0, 0, -1)).x;
	
	// Compute gradient (normal)
	vec3 gradienta = vec3(axp - axn, ayp - ayn, azp - ayn);
	vec3 gradientb = vec3(bxp - bxn, byp - byn, bzp - byn);



	vertex.normal = -vec4(normalize(vec3interpolate(gradienta, data_a.x, gradientb, data_b.x)), 0.0);

	vertex.material = data_a.x > data_b.y ? vec4(data_a.y, data_a.z, 0.0, 0.0) : vec4(data_b.y, data_b.z, 0.0, 0.0);
	vertex.material.x = (waterlevel == 1.0) ? 0.0 : vertex.material.x;

	//Output vertex
	verticies[idx] = vertex;
}