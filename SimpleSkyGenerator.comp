#version 430 core
#define PI 3.14159265358979323846

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D skyTexture;

uniform vec3 incidentLight;
const float incidentLightIntensity = length(incidentLight); // I_0

uniform mat4 viewMatInverse;
uniform vec3 cameraPos;

uniform float time;
uniform uvec2 skyTextureSize;

vec3 applyCameraRotationInverse(vec3 v) {
    return normalize((viewMatInverse * vec4(v, 1.0)).xyz);
}

vec3 get_camera_vector(vec2 resolution, vec2 coord) {
	vec2 uv = coord / resolution - vec2(0.5);
    uv.x *= resolution.x / resolution.y;
    return vec3(uv.x, uv.y, -1.0);
}

vec3 calculateSunPos() {
	return vec3(0.0, sin(-time), cos(-time));
}

vec3 calculateMoonPos() {
	return vec3(cos(time), sin(time), 0.0);
}

void main() {
    
    // get the camera vector
    vec3 simple_camera_vector = get_camera_vector(skyTextureSize, ivec2(gl_GlobalInvocationID.xy));
    vec3 camera_vector = applyCameraRotationInverse(simple_camera_vector);
    
    // Add a sun and moon
    const float cosSunRadius  = 0.01;
    const float cosMoonRadius = 0.1;
    const vec3 sunPos = calculateSunPos();
    const vec3 moonPos = calculateMoonPos();
    const float theta = dot(camera_vector, sunPos);
    const float phi = dot(camera_vector, calculateMoonPos());

    float fracAboveHorizen = sunPos.y;
    
    vec3 col = vec3(0.3, 1.0, 3.0) * max(min(1.0, fracAboveHorizen), 0.0); // percentage of circle above horizen
    //col = theta > (1.0 - cosSunRadius) ? vec3(3.0, 2.0, 1.0) : col;
    
    // apply exposure
    col = 1.0 - exp(-col);
    
    // Output to screen
    const vec4 pixel = vec4(col, 1.0);
    //const vec4 pixel = (camera_vector.y <= 0.0) ? vec4(1.0) : vec4(col, 1.0);
	imageStore(skyTexture, ivec2(gl_GlobalInvocationID.xy), pixel);
}